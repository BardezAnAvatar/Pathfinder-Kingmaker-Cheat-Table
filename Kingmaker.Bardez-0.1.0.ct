<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="27">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Attach to running game"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>

{$lua}
--code from here to `[ENABLE]` will be run for both `[ENABLE]` and `[DISABLE]`


--check to see if Mono is available. We use it to inject, so it's kind of a big deal.
if (LaunchMonoDataCollector()==0) then
  error("no mono")
end

--load structure definitions
monoAA_GETMONOSTRUCT("Player")

--constants
local playerParentEntry = "Kingmaker.Player (active game)"

--used everywhere
local addressList = getAddressList()


--Adds a child memory record to the address list
--params:
--    parentAddressEntry: MemoryRecord to append to
--    childIsHeader: Boolean value to set the child's `isGroupHeader` to
--    childName: String value to set the child's `Description` to
--    childAddress: Integer value to set the child's `Address` to
--    childOffSetCount: Integer value to set the child's `OffsetCount` to
--    childOffsets: Integer Array values to set the child's `Offset` array to
--    childType: Integer; one of the following defined global constants:
--                   vtByte=0
--                   vtWord=1
--                   vtDword=2
--                   vtQword=3
--                   vtSingle=4
--                   vtDouble=5
--                   vtString=6
--                   vtUnicodeString=7 --Only used by autoguess
--                   vtByteArray=8
--                   vtBinary=9
--                   vtAutoAssembler=11
--                   vtPointer=12 --Only used by autoguess and structures
--                   vtCustom=13
--                   vtGrouped=14
local function AddChildToParentAddressView(parentAddressEntry, childIsHeader, childName, childAddress, childOffSetCount, childOffsets, childType)
	local child = addressList.createMemoryRecord()
	child.isGroupHeader = childIsHeader
	child.Description = childName
	child.Address = childAddress
	child.Type = childType

	child.OffsetCount = childOffSetCount
	for index = 1, childOffSetCount do --apparently from 0 to 0 executes once. But from 1 to 0 does not.
		print("I'm an offset!")
		child.Offset[index] = childOffsets[index]
	end

	child.appendToEntry(parentAddressEntry)
	
	return child
end


--function to add all of the child fields of `Kingmaker.Player` to an added instance address node
local function AddPlayerFields(instanceNode, instanceAddress)
	print("hello")
	--AddChildToParentAddressView(instanceNode, false, "CrossSceneState", address, 1, {Player.CrossSceneState}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "CrossSceneState", address + Player.CrossSceneState, 0, {}, vtQword)
	
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtPointer)
end


--function to add a Kingmaker.Player address entry in the main Cheat Engine view
local function AddKingmakerPlayerAddress(address)
	--fetch the header
	local parent = addressList.getMemoryRecordByDescription(playerParentEntry)

	--attach a child
	local instance = AddChildToParentAddressView(parent, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtQword)
	AddPlayerFields(instance, address)
end


--function to search for and add `Kingmaker.Player` instances in memory to the address list
local function FindKingmakerPlayerAddresses()
	--declare variables
	local instancesOfPlayer = {}

	--TODO: remove once certain this functionality works
	print("")
	local KingmakerPlayerClassId = mono_findClass('Kingmaker', 'Player')

	--note: `mono_class_findInstancesOfClass` brings up the UI and finds a smaller list of instances.
	--      `mono_class_findInstancesOfClassListOnly` is programatic, but finds... more instances :-/

	--local instancesOfPlayer = mono_class_findInstancesOfClass(nil, KingmakerPlayerClassId)
	local instancesOfPlayer = mono_class_findInstancesOfClassListOnly(nil, KingmakerPlayerClassId)

	--create a header
	local header = addressList.createMemoryRecord()
	header.Description = playerParentEntry
	header.isGroupHeader = true
	
	--loop through results and add
	for index, foundInstance in pairs(instancesOfPlayer) do
		AddKingmakerPlayerAddress(foundInstance)
	end
end


[ENABLE]
--code from here to `[DISABLE]` will be used to enable the cheat

FindKingmakerPlayerAddresses()



[DISABLE]
--code from here till the end of the code will be used to disable the cheat

--remove the Kingmaker.Player entries
local parent = addressList.getMemoryRecordByDescription(playerParentEntry)
memoryrecord_delete(parent)


</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
