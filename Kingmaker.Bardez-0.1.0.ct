<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="27">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Attach to running game"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>

{$lua}
--code from here to `[ENABLE]` will be run for both `[ENABLE]` and `[DISABLE]`


--check to see if Mono is available. We use it to inject, so it's kind of a big deal.
if (LaunchMonoDataCollector()==0) then
	error("no mono")
end

--function to return a table of fields and their offsets for the specified class name
--params:
--    namespace: namespace of the class to get a structure definition for
--    className: name of the class to get a structure definition for
function GetFields(namespace, className)
	local classId = mono_findClass(namespace, className)
	local struct = monoform_exportStructInternal(createStructure(''), classId,
		true --[[recursive]], false --[[not static]], {'some struct map thing'}, false --[[not global]])

	local fields = {}
	for i=0, struct.Count-1 do
		local e = struct.getElement(i)
		fields[e.name] = e
	end
	return fields
end


--function to regesister the structures necessary as global variables
local function GenerateKingmakerStructureDefinitions()
	Player = GetFields('Kingmaker', 'Player')
end


--load structure definitions
GenerateKingmakerStructureDefinitions()


--constants
local playerParentEntry = "Kingmaker.Player (active game)"

--used everywhere
local addressList = getAddressList()


--Adds a child memory record to the address list
--params:
--    parentAddressEntry: MemoryRecord to append to
--    childIsHeader: Boolean value to set the child's `isGroupHeader` to
--    childName: String value to set the child's `Description` to
--    childAddress: Integer value to set the child's `Address` to
--    childOffSetCount: Integer value to set the child's `OffsetCount` to
--    childOffsets: Integer Array values to set the child's `Offset` array to
--    childType: Integer; one of the following defined global constants:
--                   vtByte=0
--                   vtWord=1
--                   vtDword=2
--                   vtQword=3
--                   vtSingle=4
--                   vtDouble=5
--                   vtString=6
--                   vtUnicodeString=7 --Only used by autoguess
--                   vtByteArray=8
--                   vtBinary=9
--                   vtAutoAssembler=11
--                   vtPointer=12 --Only used by autoguess and structures
--                   vtCustom=13
--                   vtGrouped=14
local function AddChildToParentAddressView(parentAddressEntry, childIsHeader, childName, childAddress, childOffSetCount, childOffsets, childType)
	local child = addressList.createMemoryRecord()
	child.isGroupHeader = childIsHeader
	child.Description = childName
	child.Address = childAddress
	child.Type = childType

	child.OffsetCount = childOffSetCount
	for index = 1, childOffSetCount do --apparently from 0 to 0 executes once. But from 1 to 0 does not.
		print("I'm an offset!")
		child.Offset[index] = childOffsets[index]
	end

	child.appendToEntry(parentAddressEntry)

	return child
end


--function to add all of the child fields of `Kingmaker.Player` to an added instance address node
local function AddPlayerFields(instanceNode, instanceAddress)
	--reasonably editable data fields
	AddChildToParentAddressView(instanceNode, false, "Money", instanceAddress + Player["&lt;Money&gt;k__BackingField"].Offset, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Current Formation Index", instanceAddress + Player["m_CurrentFormationIndex"].Offset, 0, {}, vtDword)
	AddChildToParentAddressView(instanceNode, false, "Chapter", instanceAddress + Player["Chapter"].Offset, 0, {}, vtDword)
	AddChildToParentAddressView(instanceNode, false, "Game ID", instanceAddress + Player["&lt;GameId&gt;k__BackingField"].Offset, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "GameTime", instanceAddress + Player["GameTime"].Offset, 0, {}, vtQword)  --System.TimeSpan
	AddChildToParentAddressView(instanceNode, false, "RealTime", instanceAddress + Player["RealTime"].Offset, 0, {}, vtQword)  --System.TimeSpan

	--pointers for testing
	AddChildToParentAddressView(instanceNode, false, "CrossSceneState", instanceAddress + Player.CrossSceneState.Offset, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Dialog State", instanceAddress + Player["m_Dialog"].Offset, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Kingdom", instanceAddress + Player["Kingdom"].Offset, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Shared Stash", instanceAddress + Player["SharedStash"].Offset, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "m_MainCharacter", instanceAddress + Player["m_MainCharacter"].Offset, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "&lt;Inventory&gt;k__BackingField", instanceAddress + Player["&lt;Inventory&gt;k__BackingField"].Offset, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Achievements", instanceAddress + Player["Achievements"].Offset, 0, {}, vtQword)


	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
end


--function to add a Kingmaker.Player address entry in the main Cheat Engine view
local function AddKingmakerPlayerAddress(address)
	--fetch the header
	local parent = addressList.getMemoryRecordByDescription(playerParentEntry)

	--attach a child
	local instance = AddChildToParentAddressView(parent, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtQword)
	AddPlayerFields(instance, address)
end


--function to evaluate whether the specified address is nil, 0, or a populated value
local function IsNilOrZero(address)
	local invalid = false
	
	if (address == nil or address == 0) then
		invalid = true
	else
		local value = readQword(address)
		print("value " .. value)
	
		if (nil == value) then invalid = true end
		if (0 == value) then invalid = true end
	end
	
	return invalid
end


--function to evaluate a Kingmaker.Player address entry and to add it in the main Cheat Engine view if it appears valid
local function AttemptAddKingmakerPlayerAddress(address)
	local appearsValid = true

	--pointers for testing
	if(IsNilOrZero(address + Player["CrossSceneState"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_QuestBook"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_UnlockableFlags"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_Dialog"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_GlobalMap"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_Camping"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["CompanionStories"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_AreaAmbienceData"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["VisitedAreasData"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["SavedInArea"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;ExCompanions&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["SteamPremiumRewards"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_MainCharacter"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;PartyCharacters&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;DetachedPartyCharacters&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;RemoteCompanions&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;Inventory&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["UISettings"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;SelectedFormation&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["CustomFormations"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["Difficulty"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;Stalker&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["Kingdom"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["SharedStash"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["REManager"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["SharedVendorTables"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["Achievements"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["InspectUnitsManager"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["UpgradeActions"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["AppliedPlayerUpgraders"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["Weather"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_Party"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_ControllableCharacters"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_ActiveCompanions"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_AllCharacters"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;GameId&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["m_CameraPos"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;GameOverReason&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["&lt;Encumbrance&gt;k__BackingField"].Offset)) then appearsValid = false end
	if(IsNilOrZero(address + Player["GogPremiumRewards"].Offset)) then appearsValid = false end

	if (appearsValid) then
		AddKingmakerPlayerAddress(address)
	end
end


--function to search for and add `Kingmaker.Player` instances in memory to the address list
local function FindKingmakerPlayerAddresses()
	--declare variables
	local instancesOfPlayer = {}

	--TODO: remove once certain this functionality works
	print("")
	local KingmakerPlayerClassId = mono_findClass('Kingmaker', 'Player')

	--note: `mono_class_findInstancesOfClass` brings up the UI and finds a smaller list of instances.
	--      `mono_class_findInstancesOfClassListOnly` is programatic, but finds... more instances :-/
	--FURTHER NOTE: all of the UI additives aside, the difference appears to be that the former UI method reads ALL of the pointers and checks them for ANY being nil or 0.


	--local instancesOfPlayer = mono_class_findInstancesOfClass(nil, KingmakerPlayerClassId)
	local instancesOfPlayer = mono_class_findInstancesOfClassListOnly(nil, KingmakerPlayerClassId)

	--create a header
	local header = addressList.createMemoryRecord()
	header.Description = playerParentEntry
	header.isGroupHeader = true

	--loop through results and add
	for index, foundInstance in pairs(instancesOfPlayer) do
		--TODO: The most obvious way to determine the active game instance by looking at found results is to watch the RealTime field. Only the active instance should be incrementing.
		-- ... unfortunately, I don't think we have access to a Wait() or a Sleep() function.

		AttemptAddKingmakerPlayerAddress(foundInstance)
	end
end


[ENABLE]
--code from here to `[DISABLE]` will be used to enable the cheat

FindKingmakerPlayerAddresses()



[DISABLE]
--code from here till the end of the code will be used to disable the cheat

--remove the Kingmaker.Player entries
local parent = addressList.getMemoryRecordByDescription(playerParentEntry)
memoryrecord_delete(parent)


</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
