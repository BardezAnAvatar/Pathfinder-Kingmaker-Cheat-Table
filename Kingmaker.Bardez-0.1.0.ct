<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="27">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Attach to running game"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>

{$lua}
--code from here to `[ENABLE]` will be run for both `[ENABLE]` and `[DISABLE]`


--check to see if Mono is available. We use it to inject, so it's kind of a big deal.
if (LaunchMonoDataCollector()==0) then
	error("no mono")
end

--function to return a table of fields and their offsets for the specified class name
--params:
--    namespace: namespace of the class to get a structure definition for
--    className: name of the class to get a structure definition for
--    static: Boolean flag; do we want to fetch static fields?
function GetFields(namespace, className, static)
	local classId = mono_findClass(namespace, className)
	local struct = monoform_exportStructInternal(createStructure(''), classId,
		true --[[recursive]], static, {'some struct map thing'}, false --[[not global]])

	local fields = {}
	for i=0, struct.Count-1 do
		local e = struct.getElement(i)
		fields[e.name] = e
	end
	return fields
end


--function to regesister the structures necessary as global variables
local function GenerateKingmakerStructureDefinitions()
	Player = GetFields('Kingmaker', 'Player', false)
	Game = GetFields('Kingmaker', 'Game', false)
	PersistentState = GetFields('Kingmaker', 'PersistentState', false)
	GameStatic = GetFields('Kingmaker', 'Game', true)
end


--function to return a base address of a specified class for its static fields to be referenced.
--params:
--    namespace: namespace of the class to get a structure definition for
--    className: name of the class to get a structure definition for
local function GetStaticBaseAddress(namespace, className)
	local classId = mono_findClass(namespace, className)
	local baseAddress = mono_class_getStaticFieldAddress(mono_enumDomains()[1], classId)

	return baseAddress
end


--load structure definitions
GenerateKingmakerStructureDefinitions()


--constants
local playerParentEntry = "Kingmaker.Player (active game)"

--used everywhere
local addressList = getAddressList()


--Adds a child memory record to the address list
--params:
--    parentAddressEntry: MemoryRecord to append to
--    childIsHeader: Boolean value to set the child's `isGroupHeader` to
--    childName: String value to set the child's `Description` to
--    childAddress: Integer value to set the child's `Address` to
--    childOffSetCount: Integer value to set the child's `OffsetCount` to
--    childOffsets: Integer Array values to set the child's `Offset` array to
--    childType: Integer; one of the following defined global constants:
--                   vtByte=0
--                   vtWord=1
--                   vtDword=2
--                   vtQword=3
--                   vtSingle=4
--                   vtDouble=5
--                   vtString=6
--                   vtUnicodeString=7 --Only used by autoguess
--                   vtByteArray=8
--                   vtBinary=9
--                   vtAutoAssembler=11
--                   vtPointer=12 --Only used by autoguess and structures
--                   vtCustom=13
--                   vtGrouped=14
--    dropDownList: an array(?) of values and displayable text for each value; nil if not intended to be populated
local function AddChildToParentAddressView(parentAddressEntry, childIsHeader, childName, childAddress, childOffSetCount, childOffsets, childType, dropDownList)
	local child = addressList.createMemoryRecord()
	child.isGroupHeader = childIsHeader
	child.Description = childName
	child.Address = childAddress
	child.Type = childType

	child.OffsetCount = childOffSetCount
	for index = 1, childOffSetCount do --apparently from 0 to 0 executes once. But from 1 to 0 does not.
		child.Offset[index] = childOffsets[index]
	end

	if (dropDownList ~= nil) then
		child.DropDownList.Text = dropDownList
	end

	child.appendToEntry(parentAddressEntry)

	return child
end


--function to add all of the child fields of `Kingmaker.Player` to an added instance address node
local function AddPlayerFields(instanceNode, instanceAddress)
	--reasonably editable data fields
	AddChildToParentAddressView(instanceNode, false, "Money", "+0x" .. string.format('%x', Player["&lt;Money&gt;k__BackingField"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Current Formation Index", "+0x" .. string.format('%x', Player["m_CurrentFormationIndex"].Offset), 0, {}, vtDword)
	AddChildToParentAddressView(instanceNode, false, "Chapter", "+0x" .. string.format('%x', Player["Chapter"].Offset), 0, {}, vtDword)
	AddChildToParentAddressView(instanceNode, false, "Game ID", "+0x" .. string.format('%x', Player["&lt;GameId&gt;k__BackingField"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "GameTime", "+0x" .. string.format('%x', Player["GameTime"].Offset), 0, {}, vtQword)  --System.TimeSpan
	AddChildToParentAddressView(instanceNode, false, "RealTime", "+0x" .. string.format('%x', Player["RealTime"].Offset), 0, {}, vtQword)  --System.TimeSpan

	local encumbrance = [[0:Light 
1:Medium
2:Heavy
3:Overencumbered]] 
	AddChildToParentAddressView(instanceNode, false, "Encumbrance", "+0x" .. string.format('%x', Player["&lt;Encumbrance&gt;k__BackingField"].Offset), 0, {}, vtDword, encumbrance)  --Kingmaker.UnitLogic.Encumbrance  (Int32 enum)


	--pointers for testing
	AddChildToParentAddressView(instanceNode, false, "CrossSceneState", "+0x" .. string.format('%x', Player["CrossSceneState"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Dialog State", "+0x" .. string.format('%x', Player["m_Dialog"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Kingdom", "+0x" .. string.format('%x', Player["Kingdom"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Shared Stash", "+0x" .. string.format('%x', Player["SharedStash"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "m_MainCharacter", "+0x" .. string.format('%x', Player["m_MainCharacter"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "&lt;Inventory&gt;k__BackingField", "+0x" .. string.format('%x', Player["&lt;Inventory&gt;k__BackingField"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Achievements", "+0x" .. string.format('%x', Player["Achievements"].Offset), 0, {}, vtQword)


	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
end


--function to add a Kingmaker.Player address entry in the main Cheat Engine view
local function AddKingmakerPlayerAddress(address)
	--fetch the header
	local parent = addressList.getMemoryRecordByDescription(playerParentEntry)

	--attach a child
	AddPlayerFields(parent, address)
end


--function to search for and add `Kingmaker.Player` instances in memory to the address list
local function FindKingmakerPlayerAddresses()
	--declare variables
	local instancesOfPlayer = {}

	--TODO: remove once certain this functionality works
	print("")

	local staticKigmakerGameBaseAddress = GetStaticBaseAddress('Kingmaker', 'Game')
	local instancePointer = readPointer(staticKigmakerGameBaseAddress + GameStatic["s_Instance"].Offset)
	local instanceStatePointer = readPointer(instancePointer + Game["State"].Offset)
	local instanceStatePlayerPointer = readPointer(instanceStatePointer + PersistentState["PlayerState"].Offset)

	--create a header
	local header = addressList.createMemoryRecord()
	header.Description = playerParentEntry
	--header.isGroupHeader = true
	header.Address = instanceStatePlayerPointer
	header.options = "[moManualExpandCollapse]" 

	AddKingmakerPlayerAddress(instanceStatePlayerPointer)
end


[ENABLE]
--code from here to `[DISABLE]` will be used to enable the cheat

FindKingmakerPlayerAddresses()



[DISABLE]
--code from here till the end of the code will be used to disable the cheat

--remove the Kingmaker.Player entries
local parent = addressList.getMemoryRecordByDescription(playerParentEntry)
memoryrecord_delete(parent)


</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>