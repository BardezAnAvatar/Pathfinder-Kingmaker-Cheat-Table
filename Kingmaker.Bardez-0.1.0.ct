<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="27">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Attach to running game"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>

{$lua}
--code from here to `[ENABLE]` will be run for both `[ENABLE]` and `[DISABLE]`


--check to see if Mono is available. We use it to inject, so it's kind of a big deal.
if (LaunchMonoDataCollector()==0) then
	error("no mono")
end

--function to return a table of fields and their offsets for the specified class name
--params:
--    namespace: namespace of the class to get a structure definition for
--    className: name of the class to get a structure definition for
function GetFields(namespace, className) 
	local classId = mono_findClass(namespace, className)
	local struct = monoform_exportStructInternal(createStructure(''), classId, 
		true --[[recursive]], false --[[not static]], {'some struct map thing'}, false --[[not global]]) 

	local fields = {} 
	for i=0, struct.Count-1 do 
		local e = struct.getElement(i) 
		fields[e.name] = e.offset 
	end 
	return fields 
end


--function to regesister the structures necessary as global variables
local function GenerateKingmakerStructureDefinitions()
	Player = GetFields('Kingmaker', 'Player')


	----DEBUG:
	--for k,v in pairs(Player) do
	--	print(k .. " " .. v)
	--end
end


--load structure definitions
GenerateKingmakerStructureDefinitions()


--constants
local playerParentEntry = "Kingmaker.Player (active game)"

--used everywhere
local addressList = getAddressList()


--Adds a child memory record to the address list
--params:
--    parentAddressEntry: MemoryRecord to append to
--    childIsHeader: Boolean value to set the child's `isGroupHeader` to
--    childName: String value to set the child's `Description` to
--    childAddress: Integer value to set the child's `Address` to
--    childOffSetCount: Integer value to set the child's `OffsetCount` to
--    childOffsets: Integer Array values to set the child's `Offset` array to
--    childType: Integer; one of the following defined global constants:
--                   vtByte=0
--                   vtWord=1
--                   vtDword=2
--                   vtQword=3
--                   vtSingle=4
--                   vtDouble=5
--                   vtString=6
--                   vtUnicodeString=7 --Only used by autoguess
--                   vtByteArray=8
--                   vtBinary=9
--                   vtAutoAssembler=11
--                   vtPointer=12 --Only used by autoguess and structures
--                   vtCustom=13
--                   vtGrouped=14
local function AddChildToParentAddressView(parentAddressEntry, childIsHeader, childName, childAddress, childOffSetCount, childOffsets, childType)
	local child = addressList.createMemoryRecord()
	child.isGroupHeader = childIsHeader
	child.Description = childName
	child.Address = childAddress
	child.Type = childType

	child.OffsetCount = childOffSetCount
	for index = 1, childOffSetCount do --apparently from 0 to 0 executes once. But from 1 to 0 does not.
		print("I'm an offset!")
		child.Offset[index] = childOffsets[index]
	end

	child.appendToEntry(parentAddressEntry)
	
	return child
end


--function to add all of the child fields of `Kingmaker.Player` to an added instance address node
local function AddPlayerFields(instanceNode, instanceAddress)
	--reasonably editable data fields
	AddChildToParentAddressView(instanceNode, false, "Money", instanceAddress + Player["&lt;Money&gt;k__BackingField"], 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Current Formation Index", instanceAddress + Player["m_CurrentFormationIndex"], 0, {}, vtDword)
	AddChildToParentAddressView(instanceNode, false, "Chapter", instanceAddress + Player["Chapter"], 0, {}, vtDword)
	AddChildToParentAddressView(instanceNode, false, "Game ID", instanceAddress + Player["&lt;GameId&gt;k__BackingField"], 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "GameTime", instanceAddress + Player["GameTime"], 0, {}, vtQword)  --System.TimeSpan
	AddChildToParentAddressView(instanceNode, false, "RealTime", instanceAddress + Player["RealTime"], 0, {}, vtQword)  --System.TimeSpan

	--pointers for testing
	AddChildToParentAddressView(instanceNode, false, "CrossSceneState", instanceAddress + Player.CrossSceneState, 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Dialog State", instanceAddress + Player["m_Dialog"], 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Kingdom", instanceAddress + Player["Kingdom"], 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Shared Stash", instanceAddress + Player["SharedStash"], 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "m_MainCharacter", instanceAddress + Player["m_MainCharacter"], 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "&lt;Inventory&gt;k__BackingField", instanceAddress + Player["&lt;Inventory&gt;k__BackingField"], 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Achievements", instanceAddress + Player["Achievements"], 0, {}, vtQword)


	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
end


--function to add a Kingmaker.Player address entry in the main Cheat Engine view
local function AddKingmakerPlayerAddress(address)
	--fetch the header
	local parent = addressList.getMemoryRecordByDescription(playerParentEntry)

	--attach a child
	local instance = AddChildToParentAddressView(parent, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtQword)
	AddPlayerFields(instance, address)
end


--function to search for and add `Kingmaker.Player` instances in memory to the address list
local function FindKingmakerPlayerAddresses()
	--declare variables
	local instancesOfPlayer = {}

	--TODO: remove once certain this functionality works
	print("")
	local KingmakerPlayerClassId = mono_findClass('Kingmaker', 'Player')

	--note: `mono_class_findInstancesOfClass` brings up the UI and finds a smaller list of instances.
	--      `mono_class_findInstancesOfClassListOnly` is programatic, but finds... more instances :-/

	--local instancesOfPlayer = mono_class_findInstancesOfClass(nil, KingmakerPlayerClassId)
	local instancesOfPlayer = mono_class_findInstancesOfClassListOnly(nil, KingmakerPlayerClassId)

	--create a header
	local header = addressList.createMemoryRecord()
	header.Description = playerParentEntry
	header.isGroupHeader = true
	
	--loop through results and add
	for index, foundInstance in pairs(instancesOfPlayer) do
		AddKingmakerPlayerAddress(foundInstance)
	end
end


[ENABLE]
--code from here to `[DISABLE]` will be used to enable the cheat

FindKingmakerPlayerAddresses()



[DISABLE]
--code from here till the end of the code will be used to disable the cheat

--remove the Kingmaker.Player entries
local parent = addressList.getMemoryRecordByDescription(playerParentEntry)
memoryrecord_delete(parent)


</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
