<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="27">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Attach to running game"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>

{$lua}
--code from here to `[ENABLE]` will be run for both `[ENABLE]` and `[DISABLE]`


--check to see if Mono is available. We use it to inject, so it's kind of a big deal.
if (LaunchMonoDataCollector()==0) then
	error("no mono")
end

--function to return a table of fields and their offsets for the specified class name
--params:
--    namespace: namespace of the class to get a structure definition for
--    className: name of the class to get a structure definition for
--    static: Boolean flag; do we want to fetch static fields?
function GetFields(namespace, className, static)
	local classId = mono_findClass(namespace, className)
	local struct = monoform_exportStructInternal(createStructure(''), classId,
		true --[[recursive]], static, {'some struct map thing'}, false --[[not global]])

	local fields = {}
	for i=0, struct.Count-1 do
		local e = struct.getElement(i)
		fields[e.name] = e
	end
	return fields
end


--function to regesister the structures necessary as global variables
local function GenerateKingmakerStructureDefinitions()
	Player = GetFields('Kingmaker', 'Player', false)
	Game = GetFields('Kingmaker', 'Game', false)
	PersistentState = GetFields('Kingmaker', 'PersistentState', false)
	GameStatic = GetFields('Kingmaker', 'Game', true)
end


--function to return a base address of a specified class for its static fields to be referenced.
--params:
--    namespace: namespace of the class to get a structure definition for
--    className: name of the class to get a structure definition for
local function GetStaticBaseAddress(namespace, className)
	local classId = mono_findClass(namespace, className)
	local baseAddress = mono_class_getStaticFieldAddress(mono_enumDomains()[1], KingmakerGameClassId)
	print( string.format('%x', baseAddress))
	
	return baseAddress
end


--load structure definitions
GenerateKingmakerStructureDefinitions()


--constants
local playerParentEntry = "Kingmaker.Player (active game)"

--used everywhere
local addressList = getAddressList()


--Adds a child memory record to the address list
--params:
--    parentAddressEntry: MemoryRecord to append to
--    childIsHeader: Boolean value to set the child's `isGroupHeader` to
--    childName: String value to set the child's `Description` to
--    childAddress: Integer value to set the child's `Address` to
--    childOffSetCount: Integer value to set the child's `OffsetCount` to
--    childOffsets: Integer Array values to set the child's `Offset` array to
--    childType: Integer; one of the following defined global constants:
--                   vtByte=0
--                   vtWord=1
--                   vtDword=2
--                   vtQword=3
--                   vtSingle=4
--                   vtDouble=5
--                   vtString=6
--                   vtUnicodeString=7 --Only used by autoguess
--                   vtByteArray=8
--                   vtBinary=9
--                   vtAutoAssembler=11
--                   vtPointer=12 --Only used by autoguess and structures
--                   vtCustom=13
--                   vtGrouped=14
local function AddChildToParentAddressView(parentAddressEntry, childIsHeader, childName, childAddress, childOffSetCount, childOffsets, childType)
	local child = addressList.createMemoryRecord()
	child.isGroupHeader = childIsHeader
	child.Description = childName
	child.Address = childAddress
	child.Type = childType

	child.OffsetCount = childOffSetCount
	for index = 1, childOffSetCount do --apparently from 0 to 0 executes once. But from 1 to 0 does not.
		print("I'm an offset!")
		child.Offset[index] = childOffsets[index]
	end

	child.appendToEntry(parentAddressEntry)

	return child
end


--function to add all of the child fields of `Kingmaker.Player` to an added instance address node
local function AddPlayerFields(instanceNode, instanceAddress)
	--reasonably editable data fields
	AddChildToParentAddressView(instanceNode, false, "Money", "+0x" .. string.format('%x', Player["&lt;Money&gt;k__BackingField"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Current Formation Index", "+0x" .. string.format('%x', Player["m_CurrentFormationIndex"].Offset), 0, {}, vtDword)
	AddChildToParentAddressView(instanceNode, false, "Chapter", "+0x" .. string.format('%x', Player["Chapter"].Offset), 0, {}, vtDword)
	AddChildToParentAddressView(instanceNode, false, "Game ID", "+0x" .. string.format('%x', Player["&lt;GameId&gt;k__BackingField"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "GameTime", "+0x" .. string.format('%x', Player["GameTime"].Offset), 0, {}, vtQword)  --System.TimeSpan
	AddChildToParentAddressView(instanceNode, false, "RealTime", "+0x" .. string.format('%x', Player["RealTime"].Offset), 0, {}, vtQword)  --System.TimeSpan

	--pointers for testing
	AddChildToParentAddressView(instanceNode, false, "CrossSceneState", "+0x" .. string.format('%x', Player["CrossSceneState"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Dialog State", "+0x" .. string.format('%x', Player["m_Dialog"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Kingdom", "+0x" .. string.format('%x', Player["Kingdom"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Shared Stash", "+0x" .. string.format('%x', Player["SharedStash"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "m_MainCharacter", "+0x" .. string.format('%x', Player["m_MainCharacter"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "&lt;Inventory&gt;k__BackingField", "+0x" .. string.format('%x', Player["&lt;Inventory&gt;k__BackingField"].Offset), 0, {}, vtQword)
	AddChildToParentAddressView(instanceNode, false, "Achievements", "+0x" .. string.format('%x', Player["Achievements"].Offset), 0, {}, vtQword)


	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
	--AddChildToParentAddressView(instanceNode, false, "Found `Kingmaker.Player` Instance", instanceAddress, 0, {}, vtPointer)
end


--function to add a Kingmaker.Player address entry in the main Cheat Engine view
local function AddKingmakerPlayerAddress(address)
	--fetch the header
	local parent = addressList.getMemoryRecordByDescription(playerParentEntry)

	--attach a child
	local instance = AddChildToParentAddressView(parent, false, "Found `Kingmaker.Player` Instance", address, 0, {}, vtQword)
	AddPlayerFields(instance, address)
end


--function to evaluate whether the specified address is nil, 0, or a populated value
local function IsNilOrZero(address, structField)
	local invalid = false
	if (structField.Vartype == vtPointer) then
		local pointer = readPointer(address + structField.Offset)

		if (pointer == nil) then
			invalid = true
		else
			if (pointer ~- 0) then
				local value = readQword(pointer)

				if (value == nil) then invalid = true end
			end
		end
	end

	return invalid
end


--function to evaluate a Kingmaker.Player address entry and to add it in the main Cheat Engine view if it appears valid
local function AttemptAddKingmakerPlayerAddress(address)
	local appearsValid = true

	--pointers for testing
	if(IsNilOrZero(address, Player["m_ActiveCompanions"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_AllCharacters"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_AreaAmbienceData"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_Camping"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_ControllableCharacters"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_Dialog"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_GlobalMap"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_MainCharacter"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_Party"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_QuestBook"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["m_UnlockableFlags"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["Achievements"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["AppliedPlayerUpgraders"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["CompanionStories"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["CrossSceneState"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["CustomFormations"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["Difficulty"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["GogPremiumRewards"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["InspectUnitsManager"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["Kingdom"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["REManager"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["SavedInArea"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["SharedStash"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["SharedVendorTables"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["SteamPremiumRewards"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["UISettings"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["UpgradeActions"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["VisitedAreasData"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["Weather"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["&lt;DetachedPartyCharacters&gt;k__BackingField"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["&lt;ExCompanions&gt;k__BackingField"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["&lt;GameId&gt;k__BackingField"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["&lt;Inventory&gt;k__BackingField"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["&lt;PartyCharacters&gt;k__BackingField"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["&lt;RemoteCompanions&gt;k__BackingField"])) then appearsValid = false end
	if(IsNilOrZero(address, Player["&lt;SelectedFormation&gt;k__BackingField"])) then appearsValid = false end
	--if(IsNilOrZero(address, Player["&lt;Stalker&gt;k__BackingField"])) then appearsValid = false end
	
	--probably enums/structs
	--if(IsNilOrZero(address, Player["m_CameraPos"])) then appearsValid = false end
	--if(IsNilOrZero(address, Player["&lt;Encumbrance&gt;k__BackingField"])) then appearsValid = false end
	--if(IsNilOrZero(address, Player["&lt;GameOverReason&gt;k__BackingField"])) then appearsValid = false end

	if (appearsValid) then
		AddKingmakerPlayerAddress(address)
	end
end


--function to search for and add `Kingmaker.Player` instances in memory to the address list
local function FindKingmakerPlayerAddresses()
	--declare variables
	local instancesOfPlayer = {}

	--TODO: remove once certain this functionality works
	print("")
	local KingmakerPlayerClassId = mono_findClass('Kingmaker', 'Player')

	--note: `mono_class_findInstancesOfClass` brings up the UI and finds a smaller list of instances.
	--      `mono_class_findInstancesOfClassListOnly` is programatic, but finds... more instances :-/
	--FURTHER NOTE: all of the UI additives aside, the difference appears to be that the former UI method reads ALL of the pointers and checks them for ANY being nil or 0.


	--local instancesOfPlayer = mono_class_findInstancesOfClass(nil, KingmakerPlayerClassId)
	local instancesOfPlayer = mono_class_findInstancesOfClassListOnly(nil, KingmakerPlayerClassId)

	--create a header
	local header = addressList.createMemoryRecord()
	header.Description = playerParentEntry
	header.isGroupHeader = true

	--loop through results and add
	for index, foundInstance in pairs(instancesOfPlayer) do
		--TODO: The most obvious way to determine the active game instance by looking at found results is to watch the RealTime field. Only the active instance should be incrementing.
		-- ... unfortunately, I don't think we have access to a Wait() or a Sleep() function.

		AttemptAddKingmakerPlayerAddress(foundInstance)
	end
end


[ENABLE]
--code from here to `[DISABLE]` will be used to enable the cheat

FindKingmakerPlayerAddresses()



[DISABLE]
--code from here till the end of the code will be used to disable the cheat

--remove the Kingmaker.Player entries
local parent = addressList.getMemoryRecordByDescription(playerParentEntry)
memoryrecord_delete(parent)


</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
