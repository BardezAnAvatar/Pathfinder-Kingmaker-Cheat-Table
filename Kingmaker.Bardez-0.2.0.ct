<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="27">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Attach to running game"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>

{$lua}
--code from here to `[ENABLE]` will be run for both `[ENABLE]` and `[DISABLE]`
print("")

--check to see if Mono is available. We use it to inject, so it's kind of a big deal.
if (LaunchMonoDataCollector()==0) then
	error("no mono")
end

--function to return a table of fields and their offsets for the specified class name
--params:
--    namespace: namespace of the class to get a structure definition for
--    className: name of the class to get a structure definition for
--    static: Boolean flag; do we want to fetch static fields?
function GetFields(namespace, className, static)
	local classId = mono_findClass(namespace, className)
	local struct = monoform_exportStructInternal(createStructure(''), classId,
		true --[[recursive]], static, {'some struct map thing'}, false --[[not global]])

	local fields = {}
	for i=0, struct.Count-1 do
		local e = struct.getElement(i)
		fields[e.name] = e
	end
	return fields
end


--function to regesister the structures necessary as global variables
local function GenerateKingmakerStructureDefinitions()
	SystemString = GetFields('System', 'String', false)
	GameStatic = GetFields('Kingmaker', 'Game', true)
	Game = GetFields('Kingmaker', 'Game', false)
	Player = GetFields('Kingmaker', 'Player', false)
	PersistentState = GetFields('Kingmaker', 'PersistentState', false)
	GlobalMapState = GetFields('Kingmaker.Globalmap.State', 'GlobalMapState', false)
	KingdomState = GetFields('Kingmaker.Kingdom', 'KingdomState', false)
	KingdomStats = GetFields('Kingmaker.Kingdom', 'KingdomStats', false)
	KingdomStat = GetFields('Kingmaker.Kingdom.KingdomStats', 'Stat', false)
	KingdomEvent = GetFields('Kingmaker.Kingdom.Tasks', 'KingdomEvent', false)

	----DEBUG:
	--for key, value in pairs(SystemString) do
	--	print("name: " .. value.Name)
	--end
end


--function to return a base address of a specified class for its static fields to be referenced.
--params:
--    namespace: namespace of the class to get a structure definition for
--    className: name of the class to get a structure definition for
local function GetStaticBaseAddress(namespace, className)
	local classId = mono_findClass(namespace, className)
	local baseAddress = mono_class_getStaticFieldAddress(mono_enumDomains()[1], classId)

	return baseAddress
end


--function to return the size of a pointer
local function GetPointerSize()
	local pointerSize = 4							--32-bit
	if (targetIs64Bit()) then pointerSize = 8 end 	--64 bit

	return pointerSize
end


--function to read a System.String from memory and return it to a Lua variable
--params:
--    address: address in memory of the `System.String` instance
local function ReadMonoStringFromAddress(address)
	local formattedAddress = string.format('%x', address)

	local sizeAddress = formattedAddress .. "+0x" .. string.format('%x', SystemString["m_stringLength"].Offset)
	local stringLength = readInteger(sizeAddress)
	local characterAddress = formattedAddress .. "+0x" .. string.format('%x', SystemString["m_firstChar"].Offset)
	local value = readString(characterAddress, stringLength * 2, true)

	return value
end


--function to traverse the internals of a System.Array after its length has been determined
--params:
--    length: number of items within the array
--    address: address of the array to start reading at
--    entryHandler: function to invoke, passing an address and returning an address, trusting that it is the address of the next array item
--    ... / arg: arguments to pass to `entryHandler`
local function TraverseMonoArray(length, address, entryHandler, ...)
	local arg = {...}  -- arg is now a table of all extra values passed to g 

	local currentAddressOffset = 32 --Magic number; apparently the first 0x20 bytes are Array internals. I cannot see these in the dissect definitions :'(

	for index = 0, length - 1 do
		currentAddressOffset = entryHandler(address, currentAddressOffset, unpack(arg))
	end
end


--function to read all items in a .NET array
--params:
--    address: address of the array to start reading at
--    entryHandler: function to invoke, passing an address and returning an address, trusting that it is the address of the next array item
--NOTE:
--    This should work, whether the entries are literals, structs, or pointers
local function ReadMonoArray(address, entryHandler, ...)
	local arg = {...}  -- arg is now a table of all extra values passed to g 
	local classId = mono_findClass("System", "Array")
	local lengthMethodId = mono_class_findMethod(classId, "get_Length")
	local arrayLength = mono_invoke_method(mono_enumDomains()[1], lengthMethodId, address, {})

	TraverseMonoArray(arrayLength, address, entryHandler, unpack(arg))
end


--function to read all items in a .NET array
--params:
--    address: address of the array to start reading at
--    entryHandler: function to invoke, passing an address and returning an address, trusting that it is the address of the next array item
--NOTE:
--    This should work, whether the entries are literals, structs, or pointers
local function ReadMonoList(address, entryHandler, ...)
	local arg = {...}  -- arg is now a table of all extra values passed to g 
	local arrayAddressOffset = string.format('%x', address) .. "+0x10"
	local listUnderlyingArrayAddress = readPointer(arrayAddressOffset)
	local lengthOffset = string.format('%x', address) .. "+0x18"
	local length = readInteger(lengthOffset)

	TraverseMonoArray(length, listUnderlyingArrayAddress, entryHandler, unpack(arg))
end


--load structure definitions
GenerateKingmakerStructureDefinitions()




--constants
local playerParentEntry = "Kingmaker.Player (active game)"

--Kingmaker.Enums.Alignment
local alignmentEnum = [[1:True Neutral
3:Neutral Good
5:Neutral Evil
9:Lawful Neutral
10:Lawful Good
12:Lawful Evil
17:Chaotic Neutral
18:Chaotic Good
20:Chaotic Evil]]

--Kingmaker.Enums.Alignment
local kingdomUnrestEnum = [[0:Crumbling
1:Unrest/Riots
2:Troubled
3:Worried
4:Stable
5:"Metastable"/Serene (debug value?)]]

--used everywhere
local addressList = getAddressList()


--Adds a child memory record to the address list
--params:
--    parentAddressEntry: MemoryRecord to append to
--    childIsHeader: Boolean value to set the child's `isGroupHeader` to
--    collapsable: Boolean value indicating whether the user should be able to collapse the address or not
--    showHex: Boolean value indicating whether the value should be displayed as hexidecimal or not
--    childName: String value to set the child's `Description` to
--    childAddress: Integer value to set the child's `Address` to. Presumed to be an offset (e.g: `+0xDEADBEEF`)
--    childType: Integer; one of the following defined global constants:
--                   vtByte=0
--                   vtWord=1
--                   vtDword=2
--                   vtQword=3
--                   vtSingle=4
--                   vtDouble=5
--                   vtString=6
--                   vtUnicodeString=7 --Only used by autoguess
--                   vtByteArray=8
--                   vtBinary=9
--                   vtAutoAssembler=11
--                   vtPointer=12 --Only used by autoguess and structures
--                   vtCustom=13
--                   vtGrouped=14
--    dropDownList: an array(?) of values and displayable text for each value; nil if not intended to be populated
--    childOffSetCount: Integer value to set the child's `OffsetCount` to
--    childOffsets: Integer Array values to set the child's `Offset` array to. NOTE: This implicitly turns the value into a pointer!
local function AddChildToParentAddressView(parentAddressEntry, childIsHeader, collapsable, showHex, childName, childAddress, childType, dropDownList, childOffSetCount, childOffsets)
	local child = addressList.createMemoryRecord()
	child.isGroupHeader = childIsHeader
	child.Description = childName
	child.Address = childAddress
	child.Type = childType

	if (childType == vtString) then
		local parentEffectiveAddress = parentAddressEntry.getCurrentAddress()
		local stringFieldAddress = string.format('%x', parentEffectiveAddress) .. childAddress -- using an implied "+" as part of the format of `childAddress` based on usage pattern. TODO: make this smarter.
		local stringAddress = string.format('%x', readPointer(stringFieldAddress))
		local sizeAddress = stringAddress .. "+0x" .. string.format('%x', SystemString["m_stringLength"].Offset)
		local stringLength = readInteger(sizeAddress)

		child.String.Size = stringLength
		child.String.Unicode = 1

		--make this a pointer
		childOffSetCount = 1
		childOffsets = { "0x" .. string.format('%x', SystemString["m_firstChar"].Offset) }
	end

	if (collapsable) then
		child.options = "[moManualExpandCollapse]"
	end

	if (showHex) then
		child.ShowAsHex = showHex
	end

	if (childOffsets ~= nil) then
		child.OffsetCount = childOffSetCount
		for index = 1, childOffSetCount do
			child.Offset[index-1] = childOffsets[index]
		end
	end

	if (dropDownList ~= nil) then
		child.DropDownList.Text = dropDownList
	end

	child.appendToEntry(parentAddressEntry)

	return child
end


--function to add all of the child fields of `Kingmaker.Globalmap.State.GlobalMapState` to an added instance address node
--params:
--    instanceNode: AddressList node that is the parent of the fields
local function AddGlobalMapStateFields(instanceNode)
	--reasonably editable data fields
	AddChildToParentAddressView(instanceNode, false, false, false, "Miles Traveled", "+0x" .. string.format('%x', GlobalMapState["&lt;MilesTravelled&gt;k__BackingField"].Offset), vtSingle)
	AddChildToParentAddressView(instanceNode, false, false, false, "Next Encounter at {value} Miles Traveled (outside of claimed Regions?)", "+0x" .. string.format('%x', GlobalMapState["&lt;NextEncounterRollMiles&gt;k__BackingField"].Offset), vtSingle)
	AddChildToParentAddressView(instanceNode, false, false, false, "Speed Modifier %", "+0x" .. string.format('%x', GlobalMapState["&lt;SpeedModifier&gt;k__BackingField"].Offset), vtSingle)
	AddChildToParentAddressView(instanceNode, false, false, false, "Speed Modifier % (in claimed Regions)", "+0x" .. string.format('%x', GlobalMapState["&lt;KingdomSpeedModifier&gt;k__BackingField"].Offset), vtSingle)
end


--function to add all of the child fields of `Kingmaker.Kingdom.KingdomState.Stat` to an added instance address node
--params:
--    arrayAddress: address in memory of the array housing pointers to `Kingmaker.Kingdom.KingdomState.Stat` instances
--    addressOffset: offset from `arrayAddress` to the current `Kingmaker.Kingdom.KingdomState.Stat`
--    parentNode: AddressList node that is the parent of the stat
local function AddKingdomStatFields(arrayAddress, addressOffset, parentNode)
	--constant table to lookup enum values
	local valueMappingTable = { [0] = "Community", [1] = "Loyalty", [2] = "Military", [3] = "Economy", [4] = "Relations", [5] = "Divine", [6] = "Arcane", [7] = "Stability", [8] = "Culture", [9] = "Espionage" }

	--read the type; this determines the label we give it.
	local statEntryOffsetString = string.format('%x', arrayAddress) .. "+0x" .. string.format('%x', addressOffset)
	local statMemoryAddress = readPointer(statEntryOffsetString)
	local relativeAddress = string.format('%x', statMemoryAddress).. "+0x" .. string.format('%x', KingdomStat["Type"].Offset)
	local statType = readInteger(relativeAddress)
	local statParent = AddChildToParentAddressView(parentNode, false, true, true, valueMappingTable[statType], "+0x" .. string.format('%x', KingdomStats["m_Stats"].Offset), vtQword, nil, 2, { 0, addressOffset })
	AddChildToParentAddressView(statParent, false, false, false, "Value", "+0x" .. string.format('%x', KingdomStat["Value"].Offset), vtDword)
	AddChildToParentAddressView(statParent, false, false, false, "Rank", "+0x" .. string.format('%x', KingdomStat["Rank"].Offset), vtDword)

	return addressOffset + GetPointerSize()
end


--function to add all of the child fields of `Kingmaker.Kingdom.Tasks.KingdomEvent` to an added instance address node
--params:
--    listAddress: address in memory of the array housing pointers to `Kingmaker.Kingdom.Tasks.KingdomEvent` instances
--    addressOffset: offset from `listAddress` to the current `Kingmaker.Kingdom.Tasks.KingdomEvent`
--    parentNode: AddressList node that is the parent of the stat
--    monoDomain: domain for invoking Mono methods
--    nameMethodId: Mono method ID for invoking a specific Mono method
local function AddKingdomEventFields(listAddress, addressOffset, parentNode, monoDomain, nameMethodId)
	--read the type; this determines the label we give it.
	local eventEntryOffsetString = string.format('%x', listAddress) .. "+0x" .. string.format('%x', addressOffset)
	local eventMemoryAddress = readPointer(eventEntryOffsetString)
	local stringNameAddress = mono_invoke_method(monoDomain, nameMethodId, eventMemoryAddress, {})
	local name = ReadMonoStringFromAddress(stringNameAddress)
	print(name)
	
	local relativeAddress = string.format('%x', eventMemoryAddress).. "+0x" .. string.format('%x', KingdomStat["Type"].Offset)
	local statType = readInteger(relativeAddress)
	local statParent = AddChildToParentAddressView(parentNode, false, true, true, name, "+0x00", vtQword, nil, 2, { 0, addressOffset })
	--AddChildToParentAddressView(statParent, false, false, false, "Value", "+0x" .. string.format('%x', KingdomStat["Value"].Offset), vtDword)
	--AddChildToParentAddressView(statParent, false, false, false, "Rank", "+0x" .. string.format('%x', KingdomStat["Rank"].Offset), vtDword)

	return addressOffset + GetPointerSize()
end


--function to add all of the child fields of `Kingmaker.Kingdom.KingdomState.Stats` to an added instance address node
--params:
--    instanceNode: AddressList node that is the parent of the fields
local function AddKingdomStateStatsFields(instanceNode)
	local statsAddress = instanceNode.getCurrentAddress()
	local relativeAddress = string.format('%x', statsAddress).. "+0x" .. string.format('%x', KingdomStats["m_Stats"].Offset)
	local statsArrayAddress = readPointer(relativeAddress)
	ReadMonoArray(statsArrayAddress, AddKingdomStatFields, instanceNode)
end


--function to add all of the child fields of `Kingmaker.Kingdom.Tasks.KingdomEvent` to an added instance address node
--params:
--    instanceNode: AddressList node that is the parent of the fields
local function AddKingdomEvents(instanceNode)
	local eventsListAddress = instanceNode.getCurrentAddress()
	local eventClassId = mono_findClass("Kingmaker.Kingdom.Tasks", "KingdomEvent")
	local nameMethodId = mono_class_findMethod(eventClassId, "get_FullName")
	local monoDomain = mono_enumDomains()[1]

	ReadMonoList(eventsListAddress, AddKingdomEventFields, instanceNode, monoDomain, nameMethodId)
end


--function to add all of the child fields of `Kingmaker.Kingdom.KingdomState` to an added instance address node
--params:
--    instanceNode: AddressList node that is the parent of the fields
local function AddKingdomStateFields(instanceNode)
	--reasonably editable data fields
	AddChildToParentAddressView(instanceNode, false, false, false, "Kingdom Name", "+0x" .. string.format('%x', KingdomState["KingdomName"].Offset), vtString)
	AddChildToParentAddressView(instanceNode, false, false, false, "Alignment", "+0x" .. string.format('%x', KingdomState["Alignment"].Offset), vtDword, alignmentEnum)
	AddChildToParentAddressView(instanceNode, false, false, false, "Start Day", "+0x" .. string.format('%x', KingdomState["&lt;StartDay&gt;k__BackingField"].Offset), vtDword)

	AddChildToParentAddressView(instanceNode, false, false, false, "Current Turn #", "+0x" .. string.format('%x', KingdomState["CurrentTurn"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "Current Day", "+0x" .. string.format('%x', KingdomState["&lt;CurrentDay&gt;k__BackingField"].Offset), vtDword)

	AddChildToParentAddressView(instanceNode, false, false, false, "BP", "+0x" .. string.format('%x', KingdomState["BP"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "BP per turn", "+0x" .. string.format('%x', KingdomState["BPPerTurn"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "BP per Region", "+0x" .. string.format('%x', KingdomState["&lt;BPPerRegion&gt;k__BackingField"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "BP per Upgrade", "+0x" .. string.format('%x', KingdomState["&lt;BPPerUpgrade&gt;k__BackingField"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "BP per turn Total", "+0x" .. string.format('%x', KingdomState["&lt;BPPerTurnTotal&gt;k__BackingField"].Offset), vtDword)

	AddChildToParentAddressView(instanceNode, false, false, false, "Region Claim Cost Modifier", "+0x" .. string.format('%x', KingdomState["&lt;ClaimCostModifier&gt;k__BackingField"].Offset), vtSingle)
	AddChildToParentAddressView(instanceNode, false, false, false, "Region Claim Time Modifier", "+0x" .. string.format('%x', KingdomState["&lt;ClaimTimeModifier&gt;k__BackingField"].Offset), vtSingle)
	AddChildToParentAddressView(instanceNode, false, false, false, "Rank Up Cost Modifier", "+0x" .. string.format('%x', KingdomState["&lt;RankupTimeModifier&gt;k__BackingField"].Offset), vtSingle)
	AddChildToParentAddressView(instanceNode, false, false, false, "Building Time Modifier", "+0x" .. string.format('%x', KingdomState["&lt;BuildingTimeModifier&gt;k__BackingField"].Offset), vtSingle)

	AddChildToParentAddressView(instanceNode, false, false, false, "Unrest", "+0x" .. string.format('%x', KingdomState["&lt;Unrest&gt;k__BackingField"].Offset), vtDword, kingdomUnrestEnum)

	--Raven crap
	AddChildToParentAddressView(instanceNode, false, false, false, "Last Raven Visit Day", "+0x" .. string.format('%x', KingdomState["LastRavenVisitDay"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "BP on Last Raven Visit", "+0x" .. string.format('%x', KingdomState["BPOnLastRavenVisit"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "Unrest on Last Raven Visit", "+0x" .. string.format('%x', KingdomState["UnrestOnLastRavenVisit"].Offset), vtDword, kingdomUnrestEnum)

	--Kingdom Stats
	local statsNode = AddChildToParentAddressView(instanceNode, false, true, true, "Stats", "+0x" .. string.format('%x', KingdomState["Stats"].Offset), vtQword, nil, 1, { 0 })
	AddKingdomStateStatsFields(statsNode)

	--Events
	local eventsNode = AddChildToParentAddressView(instanceNode, false, true, true, "Active Events", "+0x" .. string.format('%x', KingdomState["ActiveEvents"].Offset), vtQword, nil, 1, { 0 })
	AddKingdomEvents(eventsNode)

	--Tasks
	local tasksNode = AddChildToParentAddressView(instanceNode, false, true, true, "Active Tasks", "+0x" .. string.format('%x', KingdomState["ActiveTasks"].Offset), vtQword, nil, 1, { 0 })
end


--function to add all of the child fields of `Kingmaker.Player` to an added instance address node
--params:
--    instanceNode: AddressList node that is the parent of the fields
local function AddPlayerFields(instanceNode)
	--reasonably editable data fields
	AddChildToParentAddressView(instanceNode, false, false, false, "Money", "+0x" .. string.format('%x', Player["&lt;Money&gt;k__BackingField"].Offset), vtQword)
	AddChildToParentAddressView(instanceNode, false, false, false, "Current Formation Index", "+0x" .. string.format('%x', Player["m_CurrentFormationIndex"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "Chapter", "+0x" .. string.format('%x', Player["Chapter"].Offset), vtDword)
	AddChildToParentAddressView(instanceNode, false, false, false, "Game ID", "+0x" .. string.format('%x', Player["&lt;GameId&gt;k__BackingField"].Offset), vtString)
	AddChildToParentAddressView(instanceNode, false, false, false, "GameTime", "+0x" .. string.format('%x', Player["GameTime"].Offset), vtQword)  --System.TimeSpan
	AddChildToParentAddressView(instanceNode, false, false, false, "RealTime", "+0x" .. string.format('%x', Player["RealTime"].Offset), vtQword)  --System.TimeSpan

	local encumbrance = [[0:Light
1:Medium
2:Heavy
3:Overencumbered]]
	AddChildToParentAddressView(instanceNode, false, false, false, "Encumbrance", "+0x" .. string.format('%x', Player["&lt;Encumbrance&gt;k__BackingField"].Offset), vtDword, encumbrance)  --Kingmaker.UnitLogic.Encumbrance  (Int32 enum)


	--pointers to real, relevant classes
	local globalMapNode = AddChildToParentAddressView(instanceNode, false, true, true, "Global Map (World Map)", "+0x" .. string.format('%x', Player["m_GlobalMap"].Offset), vtQword, nil, 1, { 0 })
	AddGlobalMapStateFields(globalMapNode)
	local kingdomNode = AddChildToParentAddressView(instanceNode, false, true, true, "Kingdom", "+0x" .. string.format('%x', Player["Kingdom"].Offset), vtQword, nil, 1, { 0 })
	AddKingdomStateFields(kingdomNode)


	--pointers for testing
	--AddChildToParentAddressView(instanceNode, false, false, "CrossSceneState", "+0x" .. string.format('%x', Player["CrossSceneState"].Offset), vtQword)
	--AddChildToParentAddressView(instanceNode, false, false, "Dialog State", "+0x" .. string.format('%x', Player["m_Dialog"].Offset), vtQword)
	--AddChildToParentAddressView(instanceNode, false, false, "Shared Stash", "+0x" .. string.format('%x', Player["SharedStash"].Offset), vtQword)
	--AddChildToParentAddressView(instanceNode, false, false, "m_MainCharacter", "+0x" .. string.format('%x', Player["m_MainCharacter"].Offset), vtQword)
	--AddChildToParentAddressView(instanceNode, false, false, "&lt;Inventory&gt;k__BackingField", "+0x" .. string.format('%x', Player["&lt;Inventory&gt;k__BackingField"].Offset), vtQword)
	--AddChildToParentAddressView(instanceNode, false, false, "Achievements", "+0x" .. string.format('%x', Player["Achievements"].Offset), vtQword)
end


--function to add a Kingmaker.Player address entry in the main Cheat Engine view
local function AddKingmakerPlayerAddress(address)
	--fetch the header
	local parent = addressList.getMemoryRecordByDescription(playerParentEntry)

	--attach a child
	AddPlayerFields(parent)
end


--function to search for and add `Kingmaker.Player` instances in memory to the address list
local function FindKingmakerPlayerAddresses()
	--declare variables
	local instancesOfPlayer = {}

	--TODO: remove once certain this functionality works
	print("")

	local staticKigmakerGameBaseAddress = GetStaticBaseAddress('Kingmaker', 'Game')
	local instancePointer = readPointer(staticKigmakerGameBaseAddress + GameStatic["s_Instance"].Offset)
	local instanceStatePointer = readPointer(instancePointer + Game["State"].Offset)
	local instanceStatePlayerPointer = readPointer(instanceStatePointer + PersistentState["PlayerState"].Offset)

	--create a header
	local header = addressList.createMemoryRecord()
	header.Description = playerParentEntry
	--header.isGroupHeader = true
	header.Address = instanceStatePlayerPointer
	header.ShowAsHex = true
	header.options = "[moManualExpandCollapse]"

	AddKingmakerPlayerAddress(instanceStatePlayerPointer)
end


[ENABLE]
--code from here to `[DISABLE]` will be used to enable the cheat

FindKingmakerPlayerAddresses()



[DISABLE]
--code from here till the end of the code will be used to disable the cheat

--remove the Kingmaker.Player entries
local parent = addressList.getMemoryRecordByDescription(playerParentEntry)
memoryrecord_delete(parent)


</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>